# Day 16: Packet Decoder

Today's solution is probably over-engineered. Probably.

But I had a ton of fun writing this solution, and I think it taught me a lot about working with and organizing larger pieces of code in Rust. I broke a lot of the code down into modules that helped encapsulate functionality. I also managed to create some very useful test suites, without which I would be hobbling through an abyss of binary...

I implemented the packets as a recursive data type, which I was quite surprised I was able to do so easily. Just a trait, some methods in the trait module for creating the variants, and the variants themselves. I thought about implementing the whole thing with actual binary data and bit-shifting/masking, but strings made more sense because the length of binary "chunks" in the BITS protocol are not determinate like normal binary info chunks.

After completing the day, I added an `eval_string` function that prints the expression generated by BITS. I learned some interesting details about what Rust can and cannot do with required traits and certain pattern matching scenarios.

Overall, today was by far my favorite day to write up so far. I really, really hope future days use some more BITS related things...

Some interesting things I used:

- I implemented `IntoIterator` briefly, before switching back to just a normal `Iterator`. I need to learn how to use each of them. The iterator I made was non-trivial, and I was happy with the resulting ease of use.
- I organized my code into several different modules, both in code and in files.
- I wrote a lot of tests.
- I used lifetimes and it actually made sense to me!
- I used `@` bindings to pattern match.
- I briefly attempted use required traits (`trait Packet: fmt::Display`).

Some interesting things I learned:

- Rust allows test modules to access some private methods! This is heplful for testing, actually, but testing private methods can be a mixed bag.
- `dyn` is different than `impl` and `where`: `impl` and `where` actually need to be able to determine the exact types at compile time, whereas `dyn` is truly dynamic (and thus incurs penalties for performance).
- Boy is it easy to work with `&str` types. Borrowing and lifetimes made so much sense in this project, and it saved me a lot of `String` copying that I would have otherwise done.
- Rust isn't smart enough to know that if a match expressioin has `0 | 2 | 4 @ val`, the reuslting `val` can only be `0`, `2`, or `4`. It thinks it can be any value still.
- If a trait requires another (`trait X: Y`), you can't just use methods from `Y` on something like a `dyn X`. This seems like a strange limitation.

Some things I want to learn:

- Are there better ways to organize tests within a single file/module?
- What's the difference between `impl` and `where` syntax?
- Would `Result` types have cleaned up my code where I use `assert` and `panic`?
- Is there a way for clients of a `dyn MyTrait` to use the methods of a trait that `MyTrait` requires?